{
    "contents" : "# gcp-gcsSat-2015-1019 == v2 GCP, AWS sat\n#\n# author : cchapman\n\n### read data\nlibrary(gdata)\n# gcs.sat2.raw <- read.xls(\"~/Documents/Chris Documents/Work/Cloud/gcs-surveys/sat/Cloud-Sat1-Mobile-Screen1-20150601.xls\", sheet=3, stringsAsFactors=TRUE)\ngcs.sat2.raw <- read.xls(\"~/Downloads/Cloud-Sat2-Mobile-Screen1-AWS.xls\", sheet=3, stringsAsFactors=TRUE)\nstr(gcs.sat2.raw)\nnames(gcs.sat2.raw)\n\n### make initial clean set\ngcs.sat2 <- gcs.sat2.raw[ , c(4, 5, 6, 7, 8, 13:43)]\nnames(gcs.sat2)\nstr(gcs.sat2)\n\ntmp.names <- names(gcs.sat2)\ntmp.names[6] <- \"it.role\"\ntmp.names[7] <- \"cloud.leader\"\ntmp.names[13] <- \"cloudis.os.none\"\ntmp.names[14] <- \"msft.rawtext\"\ntmp.names[15] <- \"cloudis.AmznMarket\"\ntmp.names[17] <- \"cloudis.Elastic\"\ntmp.names[18] <- \"cloudis.KindlePub\"\ntmp.names[20] <- \"cloudis.amzn.none\"\ntmp.names[26] <- \"cloudis.goog.none\"\ntmp.names[27] <- \"using.AWS\"\ntmp.names[28] <- \"using.GCP\"\ntmp.names[33] <- \"using.none\"\ntmp.names[34] <- \"sat.gcp\"\ntmp.names[35] <- \"sat.aws\"\ntmp.names[36] <- \"it.hours\"\ntmp.names <- gsub(\"Question\\\\.\\\\.7\\\\.Answer\\\\.[[:digit:]]\\\\.\", \"using\", tmp.names)  # replace Q7 items with \"using ...\"\ntmp.names <- gsub(\"Question\\\\.\\\\.[[:digit:]]\\\\.Answer\\\\.[[:digit:]]\\\\.\", \"cloudis\", tmp.names)  # replace all other \"Questions\" with \"cloudis\"\n\ncbind(tmp.names, names(gcs.sat2))\nnames(gcs.sat2) <- tmp.names\n\n### clean up satisfaction scores\n# replace \"dont know\" on sat questions with missing values\ngcs.sat2$sat.aws[gcs.sat2$sat.aws == \"I don't know, or don't use these\"] <- NA\ngcs.sat2$sat.gcp[gcs.sat2$sat.gcp == \"I don't know, or don't use these\"] <- NA\n# reorder the factors\ngcs.sat2$sat.aws <- factor(gcs.sat2$sat.aws, \n                           ordered=TRUE, \n                           levels = c(\n                             \"Very dissatisfied\", \"Somewhat dissatisfied\",\n                             \"Neither satisfied nor dissatisfied\", \n                             \"Somewhat satisfied\", \"Very satisfied\" ))\ngcs.sat2$sat.gcp <- factor(gcs.sat2$sat.gcp, \n                           ordered=TRUE, \n                           levels = c(\n  \"Very dissatisfied\", \"Somewhat dissatisfied\",\n  \"Neither satisfied nor dissatisfied\", \n  \"Somewhat satisfied\", \"Very satisfied\" ))\n\n\n\n\n\n\n##########################################\n### determine \"good\" respondents\n\ngcs.good <- rep(TRUE, nrow(gcs.sat2))   # all good by default\n\n### good step 1 ==> claim cloud\ngcs.claim.cloud <- apply(gcs.sat2[ ,27:32], 1, function(x) sum(as.character(x)>\" \")) > 0\n# table(gcs.claim.cloud)\n\n\n###\n### good step 2 ==> name MSFT service correctly ===> saved for validation only!!\n\ngcp.text.score <- function(textraw, matchlist) {\n  textdata <- gsub(\"[[:punct:]]\", \"\", textraw)\n  # textdata <- tolower(textdata)     ### fails for multibyte encoding\n  tmp.score <- rep(FALSE, length(textdata))\n  for (i in seq_along(matchlist)) {\n    tmp.score <- (tmp.score | grepl(matchlist[i], textdata, ignore.case=TRUE))\n  }\n  return(tmp.score)\n}\n\nmsft.passlist <- c(\"azure\")\ngcs.msft.score <- gcp.text.score(gcs.sat2$msft.rawtext, msft.passlist)\ntable(gcs.claim.cloud, gcs.msft.score)\n\n\n###\n### good step 3 ==> name leader correctly\n### NOTE:::: starting with v2, this should always be 100% because it's a screening item in GCS\ngcs.sat2.namelead <- gcs.sat2$cloud.leader==\"Amazon\"\ntable(gcs.msft.score, gcs.sat2.namelead)\n\n###\n### good step 4 ==> pass knowledge screener with 12/18 or better\n\ngcs.sat2[, 13] <- 0  # never matches \"none of the above\" in v2 because of screener to endorse Linux\n\ngcs.answer.key <- c(0, 1, 0, 1, 1, 0,   # OS\n                    0, 1, 1, 0, 1, 0,   # Amazon\n                    0, 1, 1, 1, 0, 0 )  # Google\n\ngcs.score <- rep(NA, nrow(gcs.sat2))\nfor (i in seq_along(gcs.sat2[, 1])) { gcs.score[i] <- sum(as.numeric(gcs.sat2[i, c(8:13, 15:26)])-1 == gcs.answer.key) }\n\ntable(gcs.claim.cloud & gcs.score >= 12 & gcs.sat2.namelead, gcs.msft.score)\n\n\n###\n### good step 5 ==> get 3/5 correct for the service they user\n\nscore.items <- function(data, pos, neg) {\n  tmp.score <- rep(0, nrow(data))\n  for (i in pos) {\n    tmp.score <- tmp.score + ifelse(as.character(data[ , i]) > \" \", 1, 0)\n  }\n  for (i in neg) {\n    tmp.score <- tmp.score - ifelse(as.character(data[ , i]) > \" \", 1, 0)\n  }\n  return(tmp.score)\n}\n\nuse.aws <- as.character(gcs.sat2$using.AWS) > \" \"\naws.score <- score.items(gcs.sat2, pos=c(16, 17, 19), neg=c(15, 18, 20))\ntable(aws.score)\ngcs.aws.good <- ifelse(use.aws, aws.score >=2, TRUE)\ntable(gcs.aws.good)\n\nuse.gcp <- as.character(gcs.sat2$using.GCP) > \" \"\ngcp.score <- score.items(gcs.sat2, pos=c(22, 23, 24), neg=c(21, 25, 26))\ntable(gcp.score)\ngcs.gcp.good <- ifelse(use.gcp, gcp.score >=2, TRUE)\ntable(gcs.gcp.good)\n\n\ngcs.sat2.good <- gcs.claim.cloud & gcs.sat2.namelead & gcs.aws.good & gcs.gcp.good & gcs.score >= 12\n\n### check validity vs azure \n## for GCP users\nprop.table(table(gcs.sat2.good, gcs.msft.score, gcs.sat2$using.GCP), margin=c(1,3))\n## for AWS users\nprop.table(table(gcs.sat2.good, gcs.msft.score, gcs.sat2$using.AWS), margin=c(1,3))\n\n\n### AWS sat\nprop.table(table(gcs.sat2$sat.aws[gcs.sat2.good & use.aws]))\n\n### GCP sat\nprop.table(table(gcs.sat2$sat.gcp[gcs.sat2.good & use.gcp]))\n\n### AWS & GCP for users of both\nprop.table(table(gcs.sat2$sat.aws[gcs.sat2.good & use.aws & use.gcp]))  # AWS\nprop.table(table(gcs.sat2$sat.gcp[gcs.sat2.good & use.aws & use.gcp]))  # GCP\n\n\n########\nwith(gcs.sat2[gcs.sat2.good,], prop.table(table(using.GCP, using.AWS), margin=1))  # Odds of AWS\nwith(gcs.sat2[gcs.sat2.good,], prop.table(table(using.GCP, using.AWS), margin=2))  # Odds of GCP\n\n\n#### ECDF\n\nplot(ecdf(gcs.score[gcs.claim.cloud]), \n     do.points=FALSE, col=\"red\", verticals=TRUE, col.vert=\"gray90\",\n     main=\"Claim Cloud usage (red), vs. Knowledgeable (green)\",\n     ylab=\"Cumulative proportion scoring at or below X value\", xlab=\"Correct answers out of 18\")\nlines(ecdf(gcs.score[gcs.sat2.good]), \n      do.points=FALSE, col=\"green4\", verticals=TRUE, col.vert=\"gray90\")\n\n(ecdf.pt <- ecdf(gcs.score[gcs.claim.cloud])(12))\n\nabline(h=ecdf.pt, lty=2, lwd=2, col=\"plum\")\ntext(x=7, y=(ecdf.pt-0.03), paste0(round(ecdf.pt,2)*100,\"% of *claimed* users scored lower than 12\"))\n\n\n### get subset of just good respondents' sat data\ngcs.satdata0 <- cbind(gcs.sat2[ , c(1,2,4,5,6,32,34:36)], good=gcs.sat2.good, use.aws, use.gcp)\ngcs.satdata0 <- subset(gcs.satdata0, good)\ngcs.satdata0$id <- 1:nrow(gcs.satdata0)\nstr(gcs.satdata0)\n\n### convert to long format\ngcs.satdata1 <- data.frame(sat=gcs.satdata0[gcs.satdata0$use.aws, \"sat.aws\"], what=\"aws\", \n                           use.both=factor(gcs.satdata0[gcs.satdata0$use.aws, \"use.gcp\"]), \n                           id=gcs.satdata0[gcs.satdata0$use.aws, \"id\"],\n                           use.azure=factor(gcs.satdata0[gcs.satdata0$use.aws, \"using.Microsoft.Azure\"] != \"\"),\n                           role=gcs.satdata0[gcs.satdata0$use.aws, \"it.role\"],\n                           gender=gcs.satdata0[gcs.satdata0$use.aws, \"Gender\"],\n                           age=gcs.satdata0[gcs.satdata0$use.aws, \"Age\"],\n                           urban=gcs.satdata0[gcs.satdata0$use.aws, \"Urban.Density\"],\n                           it.hours=gcs.satdata0[gcs.satdata0$use.aws, \"it.hours\"] )\n\ngcs.satdata2 <- data.frame(sat=gcs.satdata0[gcs.satdata0$use.gcp, \"sat.gcp\"], what=\"gcp\", \n                           use.both=factor(gcs.satdata0[gcs.satdata0$use.gcp, \"use.aws\"]), \n                           id=gcs.satdata0[gcs.satdata0$use.gcp, \"id\"],\n                           use.azure=factor(gcs.satdata0[gcs.satdata0$use.gcp, \"using.Microsoft.Azure\"] != \"\"),\n                           role=gcs.satdata0[gcs.satdata0$use.gcp, \"it.role\"],\n                           gender=gcs.satdata0[gcs.satdata0$use.gcp, \"Gender\"],\n                           age=gcs.satdata0[gcs.satdata0$use.gcp, \"Age\"],\n                           urban=gcs.satdata0[gcs.satdata0$use.gcp, \"Urban.Density\"],\n                           it.hours=gcs.satdata0[gcs.satdata0$use.gcp, \"it.hours\"])\n\n\ngcs.satdata <- rbind(gcs.satdata1, gcs.satdata2)\nstr(gcs.satdata)\n\ntable(gcs.satdata$what)\n\n######\n###### CHECK THIS CAREFULLY !!! \n\nlevels(gcs.satdata$role)\n(levels(gcs.satdata$role) <- c(\"Management\",\"IT ops\", \"SW Dev\", \"SW Test\"))\n\n\n######\n######\n\n\nlibrary(ggplot2)\nlibrary(scales)\n\n# chi-square tests association but treats SAT as nominal, not as ordered\ntable(gcs.satdata$sat, gcs.satdata$what)\nchisq.test(table(gcs.satdata$sat, gcs.satdata$what))\nprint(prop.table(table(gcs.satdata$sat, gcs.satdata$what), margin=2), digits=2)\n\n# CMHtest takes ordinal nature of SAT into account\nlibrary(vcdExtra)\nCMHtest(what ~ sat, data=gcs.satdata)\nCMHtest(table(gcs.satdata$sat, gcs.satdata$what))\n\n# CMH test essentially identical to ANOVA, coding ordinal as 1:K ...\nsummary(aov(as.numeric(sat) ~ what, data=gcs.satdata))\n\n\n####### PLOTS\n\n# plot them\npar(mfrow=c(1, 1), mar=c(4, 4, 5, 15))\nbarplot(prop.table(table(gcs.satdata$sat, gcs.satdata$what), margin=2), \n        beside=TRUE, ylab=\"Proportion of respondents by platform\")\n\npar(xpd=TRUE)\nlegend(\"bottomright\", fill = gray(2:6/7), inset=c(-0.65, 0.01),\n       legend = levels(unique(gcs.satdata$sat)))\n\n\n# mosaic\nlibrary(vcd)\nmosaicplot(table(gcs.satdata$what, gcs.satdata$sat), cex=1, color=T, las=1)  # las sets labels to horizontal (1)\nmosaicplot(table(gcs.satdata$what, gcs.satdata$sat), cex=1, color=rev(terrain.colors(5)), las=1)  # las sets labels to horizontal (1)\n\n\n\n\n###################\n##\n## ggplot versions with CIs\n\n# function to resample and estimate CIs for raw counts\n#\ncount.boot <- function(count.data, count.levels=NA,\n                       boot.k=1000, big.mult=10000000/sum(count.data), \n                       alpha=0.05, silent=FALSE, samp.k=sum(count.data)) {\n  if (length(count.levels) == 1 && is.na(count.levels)) {\n    count.levels <- 1:length(count.data)\n  }\n  bigData <- rep(count.levels, times=count.data*big.mult)\n  table(bigData)\n  \n  boot.out <- matrix(NA, nrow=boot.k, ncol=length(count.data))\n  \n  # samp.k <- sum(count.data)\n  \n  if (boot.k > 100 && !silent) {\n    cat(\"Bootstrapping \")\n  }\n  \n  for (i in 1:boot.k) {\n    if (!silent && i %% 100 == 0) {\n      cat(\".\")\n    }\n    boot.samp <- sample(bigData, samp.k)\n    boot.p <- prop.table(table(factor(boot.samp, levels=count.levels)))\n    boot.out[i, ] <- as.numeric(boot.p)\n  }\n  \n  if (boot.k > 100 && !silent) {\n    cat(\" done.\\n\\n\")\n  }\n  \n  return(t(apply(boot.out, 2, \n                 function(x) quantile(x, probs=c(alpha/2, 0.5, 1-alpha/2)))))\n}\n\n\ncount.plotci <- function(dt, mlabel=\"Ratings\", ylabel=\"Proportion (with 95% CI)\") {\n  library(ggplot2)\n  library(scales)   # for rescaling\n  p <- ggplot(dt, aes(x=Sat, y=X50., ymax=X2.5., ymin=X97.5.))\n  p <- p + geom_bar(fill = \"grey50\", stat = \"identity\") \n  p <- p + geom_errorbar(aes(fill=Sat), col=\"red\", width=0.2)\n  p <- p + scale_y_continuous(limits=c(0.0, 0.6), oob = rescale_none)\n  p <- p + ggtitle(mlabel) + theme(plot.title = element_text(lineheight=1.0, face=\"bold\"))\n  p <- p + labs(x=\"Satisfaction rating\", y=ylabel) +\n    theme(text = element_text(size=14),\n          axis.text.x = element_text(angle=-10, vjust=0.6))\n  p\n}\n\n# plot Sat for GCP\n(counts.gcp <- table(gcs.satdata$sat[gcs.satdata$what==\"gcp\"]))\nsum(counts.gcp)\ncount.gcp.ci <- count.boot(counts.gcp)\ncount.ci.df <- data.frame(count.gcp.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat2$sat.gcp))\ncount.plotci(count.ci.df, mlabel=paste0(\"GCP Satisfaction Ratings (N=\", sum(counts.gcp), \")\" ))\ncount.ci.df\n\n\n# plot Sat for AWS\n(counts.aws <- table(gcs.satdata$sat[gcs.satdata$what==\"aws\"]))\nsum(counts.aws)\ncount.aws.ci <- count.boot(counts.aws)\ncount.ci.df <- data.frame(count.aws.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat2$sat.aws))\ncount.plotci(count.ci.df, mlabel=paste0(\"AWS Satisfaction Ratings (N=\", sum(counts.aws), \")\"))\ncount.ci.df\n\n\n\n\n#####################   START\n#####################\n\n# GCP, FT dev only\n(counts.gcp <- table(gcs.satdata$sat[gcs.satdata$what==\"gcp\" &\n                                        gcs.satdata$role==\"SW Dev\" &\n                                        gcs.satdata$it.hours==\"Work full time in IT\"]))\n\npt <- prop.table(counts.gcp)\npt\npt[4] + pt[5]\npt[5] - pt[1] - pt[2] - pt[3]\n\ncount.gcp.ci <- count.boot(counts.gcp)\ncount.ci.df <- data.frame(count.gcp.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat2$sat.gcp))\ncount.plotci(count.ci.df, mlabel=paste0(\"FT Developer GCP Sat (N=\", sum(counts.gcp), \")\"))\n\n# AWS FT dev only\n(counts.gcp <- table(gcs.satdata$sat[gcs.satdata$what==\"aws\" &\n                                        gcs.satdata$role==\"SW Dev\" &\n                                        gcs.satdata$it.hours==\"Work full time in IT\"]))\n\npt <- prop.table(counts.gcp)\npt\npt[4] + pt[5]\npt[5] - pt[1] - pt[2] - pt[3]\n\ncount.gcp.ci <- count.boot(counts.gcp)\ncount.ci.df <- data.frame(count.gcp.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat2$sat.gcp))\ncount.plotci(count.ci.df, mlabel=paste0(\"FT Developer AWS Sat (N=\", sum(counts.gcp), \")\"))\n\n\n#####################   END\n#####################\n\n\n######### small sample bootstrap for comparison\n\nthree.boot <- function(count.data, count.levels=NA,\n                       boot.k=1000, big.mult=10000000/sum(count.data), \n                       alpha=0.05, silent=FALSE, samp.k=sum(count.data)) {\n  if (length(count.levels) == 1 && is.na(count.levels)) {\n    count.levels <- 1:length(count.data)\n  }\n  bigData <- rep(count.levels, times=count.data*big.mult)\n  table(bigData)\n  \n  boot.out <- matrix(NA, nrow=boot.k, ncol=3)\n  \n  if (boot.k > 100 && !silent) {\n    cat(\"Bootstrapping \")\n  }\n  \n  for (i in 1:boot.k) {\n    if (!silent && i %% 100 == 0) {\n      cat(\".\")\n    }\n    boot.samp <- sample(bigData, samp.k)\n    boot.p <- prop.table(table(factor(boot.samp, levels=count.levels)))\n    # top 2 box\n    boot.out[i, 1] <- as.numeric(boot.p[5]) + as.numeric(boot.p[4])\n    # top 2 box\n    boot.out[i, 2] <- as.numeric(boot.p[5])\n    # pseudo NPS\n    boot.out[i, 3] <- as.numeric(boot.p[5]) - as.numeric(boot.p[3]) - as.numeric(boot.p[2]) - as.numeric(boot.p[1])\n  }\n  \n  if (boot.k > 100 && !silent) {\n    cat(\" done.\\n\\n\")\n  }\n  \n  return(t(apply(boot.out, 2, \n                 function(x) quantile(x, probs=c(alpha/2, 0.5, 1-alpha/2)))))\n}\n\n\n(counts.gcp <- table(gcs.satdata$sat[gcs.satdata$what==\"gcp\"]))\nset.seed(98103)\nthree.lines <- \"\"\n\n# for (n.samp in c(10, 20, 30, 50, 100, 200, 300, 500, 1000, sum(counts.gcp))) {\nfor (n.samp in c(sum(counts.gcp))) {\n# for (n.samp in c(500)) {  \n    cat(\"Sample size = \", n.samp, \"\\n\")\n  three.res <- three.boot(counts.gcp, samp.k=n.samp, boot.k=1000)\n  three.txt <- paste0(\", N = \", n.samp, \",\",\n                      round(three.res[1,1],2), \"-\", round(three.res[1,3],2), \",\",\n                      round(three.res[2,1],2), \"-\", round(three.res[2,3],2), \",\",\n                      round(three.res[3,1],2), \"-\", round(three.res[3,3],2), \",\",\n                      round(three.res[1,2],2), \",\",\n                      round(three.res[2,2],2), \",\",\n                      round(three.res[3,2],2)\n  )\n  \n  three.lines <- rbind(three.lines, three.txt)\n  \n}\nthree.lines\n\n\n\n### same for AWS\n\n(counts.aws <- table(gcs.satdata$sat[gcs.satdata$what==\"aws\"]))\nset.seed(98103)\nthree.lines <- \"\"\n\n# for (n.samp in c(10, 20, 30, 50, 100, 200, 300, 500, 1000, sum(counts.aws))) {\nfor (n.samp in c(sum(counts.aws))) {\n# for (n.samp in c(500)) {  \n  cat(\"Sample size = \", n.samp, \"\\n\")\n  three.res <- three.boot(counts.aws, samp.k=n.samp, boot.k=1000)\n  three.txt <- paste0(\", N = \", n.samp, \",\",\n                      round(three.res[1,1],2), \"-\", round(three.res[1,3],2), \",\",\n                      round(three.res[2,1],2), \"-\", round(three.res[2,3],2), \",\",\n                      round(three.res[3,1],2), \"-\", round(three.res[3,3],2), \",\",\n                      round(three.res[1,2],2), \",\",\n                      round(three.res[2,2],2), \",\",\n                      round(three.res[3,2],2)\n  )\n  three.lines <- rbind(three.lines, three.txt)\n  \n}\nthree.lines\n\n\n\n\n\n\n\n\n\n\n\n##### UPDATED TO HERE, 10/19\n\n\n\n\n\n\n\n\n\n######## REGRESSION\n\n\n## test regression from melted data\n\n\n####  ===>    need to update for NON-mixed model\n\n# basic lm model -- using sat as numeric for simplicity -- to test VIF, etc\nsat.lm <- lm(as.numeric(sat) ~ what + use.both + use.both:what + use.azure + use.azure:what +\n                                role + it.hours , data=gcs.satdata )\nsummary(sat.lm)\n# sat.lm.ci <- confint(sat.lm)\n\nlibrary(car)\nvif(sat.lm)    # looks OK\n\n\nlibrary(ordinal)\nsat.clm0 <- clm(sat ~ what + use.both + use.both:what + use.azure + use.azure:what +\n                  role + it.hours, \n                  data=gcs.satdata )\nsummary(sat.clm0)\n\n\n# HLM version  ===  deficient due to sparsity in (1|id) vs. effects\n#\n# library(lme4)\n# sat.lm <- lmer(as.numeric(sat) ~ what + use.both + use.azure + use.azure:what +\n#                  role + it.hours + (1 | id), data=gcs.satdata )\n# summary(sat.lm)\n(sat.lm.ci0 <- confint(sat.lm))\n# fixef(sat.lm)\n\nsat.lm.ci <- cbind(ci2.5=sat.lm.ci0[2:15,1],  ci97.5=sat.lm.ci0[2:15,2], ci50=coef(sat.lm)[-1])\n\n\n\n### Ordinal version\nlibrary(ordinal)\nsat.clm <- clm2(sat ~ what + use.both + use.both:what + use.azure + use.azure:what +\n                  role , data=gcs.satdata )\nsummary(sat.clm)\n\n(sat.clm.ci0 <- confint(sat.clm))\n\nsat.clm.ci <- cbind(ci2.5=sat.clm.ci0[1:8,1],  ci97.5=sat.clm.ci0[1:8,2], ci50=as.numeric(coef(sat.clm)[5:12]))\nsat.clm.ci\n\n\n\n# Bayesian HLM version\n###### ==>  not working, convergence is wacky. will use freq HLM for now.\n#\n# library(MCMCpack)\n# gcs.satdata.num <- na.omit(gcs.satdata)\n# gcs.satdata.num$sat <- as.numeric(gcs.satdata.num$sat)\n# str(gcs.satdata.num)\n\n# sat.mcmc <- MCMChregress(fixed= sat ~ what + use.both + use.both:what + use.azure + \n#                            use.azure:what + role + it.hours,\n#                          random = ~1,\n#                          group = \"id\", \n#                          r=1, R=diag(1),  \n#                          data=gcs.satdata.num )\n# str(sat.mcmc$mcmc)\n# summary(sat.mcmc$mcmc[,1:16])\n# \n# \n# sat.lm.mcmc.ci <- apply(sat.mcmc$mcmc, 2, quantile, prob=c(0.025, 0.5, 0.975))\n# \n# sat.lm.ci0 <- confint(sat.lm)\n# fixef(sat.lm)\n# sat.lm.ci <- cbind(ci2.5=sat.lm.ci0[4:17,1],  ci97.5=sat.lm.ci0[4:17,2], ci50=fixef(sat.lm)[-1])\n# \n\n\n## Bayes LM model (non-hierarchical)\ngcs.satdata.num <- na.omit(gcs.satdata)\ngcs.satdata.num$sat <- as.numeric(gcs.satdata.num$sat)\nstr(gcs.satdata.num)\n\nlibrary(MCMCpack)\nsat.lm0.mc <- MCMCregress(sat ~ what + use.both + use.both*what + use.azure + use.azure:what +\n                role + it.hours +role, data=gcs.satdata.num )\n\nsummary(sat.lm0.mc)\n\n(sat.lm.mc.ci <- t(apply(sat.lm0.mc[1001:10000,2:15], 2, function(x) quantile(x, pr=c(0.025, 0.975, 0.5)))))\nsat.lm.mc.ci <- data.frame(sat.lm.mc.ci)\nnames(sat.lm.mc.ci) <- c(\"ci2.5\", \"ci97.5\", \"ci50\")\nsat.lm.mc.ci\n\n\n## est ordinal Bayes model using Zelig\n### incomplete ...\n\n# sat.glm.zelig <- zelig(sat ~ what + use.both + use.both:what + use.azure + use.azure:what +\n#                                      role + it.hours, data=na.omit(gcs.satdata),\n#                                    model=\"oprobit.bayes\")\n# str(sat.glm.zelig)\n# \n# sat.glm.z <- apply(sat.glm.zelig$result$coefficients[1001:10000,], 2, mean)\n# \n# sat.modeled.z <- data.frame(aws = c(VerySatisfied=0, SomewhatSatisfied=0, Neither=0, SomewhatDissatisfied=0, VeryDissatisfied=0),\n#                             gcp = c(VerySatisfied=0, SomewhatSatisfied=0, Neither=0, SomewhatDissatisfied=0, VeryDissatisfied=0))\n# \n# (sat.modeled.z$aws <- diff(pnorm(c(-Inf, sat.glm.z[16:18] - sat.glm.z[6] -sat.glm.z[9]), Inf)))  # AWS\n# (sat.modeled.z$gcp <- diff(pnorm(c(-Inf, sat.glm.z[16:18]-sat.glm.z$beta[1]-sat.glm.zelig$beta[5]-sat.glm.zelig$beta[8], Inf))))  # GCP\n# \n# sat.mod.tab.z <- as.table(setNames(sat.modeled.z$aws, rev(row.names(sat.modeled.z))))\n# sat.mod.tab.z <- rbind(sat.mod.tab.z, sat.modeled.z$gcp)\n# dimnames(sat.mod.tab.z)[[1]] <- c(\"aws\", \"gcp\")\n# sat.mod.tab.z\n# \n### matched sample\n# what.odds <- glm(what ~ . - sat, data=gcs.satdata, family=binomial)\n# summary(what.odds)\n# \n# library(MatchIt)\n# sat.tomatch <- na.omit(gcs.satdata)\n# sat.tomatch$what <- sat.tomatch$what == \"gcp\"\n# summary(sat.tomatch)\n# \n# sat.m <- matchit(what ~ use.both + use.azure + role + gender + age + urban + it.hours + qorder, \n#                  data=sat.tomatch, method=\"genetic\", pop.size=400)\n# \n# # **\n# sat.matched <- match.data(sat.m)\n# sat.matched$gcp <- sat.matched$what\n# sat.matched$what <- factor(ifelse(sat.matched$gcp, \"gcp\", \"aws\"))\n# \n# \n# ### core Sat post-matching\n# # plot them\n# par(mfrow=c(1, 1), mar=c(4, 4, 5, 15))\n# barplot(prop.table(table(sat.matched$sat, sat.matched$what), margin=2), \n#         beside=TRUE, ylab=\"Proportion of respondents by platform\")\n# \n# par(xpd=TRUE)\n# legend(\"bottomright\", fill = gray(2:6/7), inset=c(-0.65, 0.01),\n#        legend = levels(unique(sat.matched$sat)))\n# \n# \n# ### NPS like scores\n# (pt.aws <- prop.table(table(sat.matched$sat[sat.matched$what==\"aws\"])))\n# (pseudo.nps.aws <- pt.aws[5] - pt.aws[3] - pt.aws[2] - pt.aws[1])\n# \n# (pt.gcp <- prop.table(table(sat.matched$sat[sat.matched$what==\"gcp\"])))\n# (pseudo.nps.gcp <- pt.gcp[5] - pt.gcp[3] - pt.gcp[2] - pt.gcp[1])\n# \n\n### Figure INFERRED sat from coefficients\n###\n### using CLM \n\n\n### clm.pred() adapted from CLMM vignette, Christensen 2015, p. 7\n# clm.pred <- function(eta, theta, cat = 1:(length(theta)+1), inv.link = plogis) {\n#   Theta <- c(-1e3, theta, 1e3)\n#   sapply(cat, \n#          function(j) inv.link(Theta[j+1] - eta) - inv.link(Theta[j] - eta) )\n# }\n#     \n# clm.pred(qnorm(0.05) * sat.clm$stDev, sat.clm$Theta)\n# \n# \n# ?clmm2\n# \n# sat.modeled <- data.frame(aws = c(VerySatisfied=0, SomewhatSatisfied=0, Neither=0, SomewhatDissatisfied=0, VeryDissatisfied=0),\n#                           gcp = c(VerySatisfied=0, SomewhatSatisfied=0, Neither=0, SomewhatDissatisfied=0, VeryDissatisfied=0))\n# \n# (sat.modeled$aws <- diff(plogis(c(-Inf, sat.clm$Theta-sat.clm$beta[5]-sat.clm$beta[8], Inf))))  # AWS\n# (sat.modeled$gcp <- diff(plogis(c(-Inf, sat.clm$Theta-sat.clm$beta[1]-sat.clm$beta[5]-sat.clm$beta[8], Inf))))  # GCP\n# \n# sat.mod.tab <- as.table(setNames(sat.modeled$aws, rev(row.names(sat.modeled))))\n# sat.mod.tab <- rbind(sat.mod.tab, sat.modeled$gcp)\n# dimnames(sat.mod.tab)[[1]] <- c(\"aws\", \"gcp\")\n# sat.mod.tab\n# \n# par(mfrow=c(1, 1), mar=c(4, 4, 5, 15))\n# barplot(t(sat.mod.tab),\n#         beside=TRUE, ylab=\"Proportion of respondents by platform\")\n# \n# par(xpd=TRUE)\n# legend(\"bottomright\", fill = gray(2:6/7), inset=c(-0.65, 0.01),\n#        legend = levels(unique(sat.matched$sat)))\n# \n\n## pseudo NPS\nsat.mod.tab[,4] + sat.mod.tab[,5]\nsat.mod.tab[,5] - sat.mod.tab[,1]-sat.mod.tab[,2]-sat.mod.tab[,3]\n\n\n\n### **\n\n### CI plot for CLM\n\n\nci.plot <- function(cidata, setnames=FALSE, ci.alpha=0.95, xlab=\"\", ci.title=\"% CI for Effect by Factor\") {\n  ci.df <- data.frame(cidata)\n  # set factor manually in order to force the level order to match lm\n  if (setnames) {\n    rownames(ci.df) <- c(\"Using GCP\", \"Using GCP&AWS\", \"Using Azure\", \n                         \"IT Ops\", \"SW Dev\", \"SW Test\", \n                         #                     \"Male\", \"Age35-44\", \"Age45-54\", \"Age55+\", \n                         #                     \"Suburban\", \"Urban\", \n                         \"Not working\", \"IT FTE\", \"Non-IT FTE\", \"FTE +IT PTE\", \"IT PTE\", \"Non-IT PTE\", \n                         \"GCP penalty if +AWS\", \"GCP bump if +Azure\")\n  }\n  ci.df$Factor <- factor(rownames(ci.df), levels=rev(rownames(ci.df)))\n  \n  # basic plot with segment, 50% and 95% limits\n  p <- ggplot(ci.df, aes(x=Factor, y=ci50, ymax=ci2.5, ymin=ci97.5))\n  p <- p + geom_point(size=4) + geom_errorbar(width=0.2) + \n    theme(axis.text.x = element_text(colour=\"grey20\",size=16)) +\n    theme(axis.text.y = element_text(colour=\"grey20\",size=16)) +\n    \n    ylab(xlab) +\n    geom_hline(yintercept=0, linetype=\"dotted\", size=1.5, color=\"red\")\n  p + ggtitle(paste0(ci.alpha*100, ci.title)) + coord_flip()\n  \n}\n\nci.plot(sat.lm.ci, setnames=FALSE, xlab=\"Effect (points of satisfaction)\")\nci.plot(2*plogis(sat.clm.ci)-1, setnames=TRUE, xlab=\"Effect (rescaled logit units)\")\nci.plot(sat.lm.mc.ci, setnames=TRUE, xlab=\"Effect (points of satisfaction)\",\n        ci.title = \"% Bayesian credible intervals (lm model)\")\n### **\n\n\n\n### NPS like scores\n(pt.aws <- prop.table(table(gcs.satdata$sat[gcs.satdata$what==\"aws\"])))\n(pseudo.nps.aws <- pt.aws[5] - pt.aws[3] - pt.aws[2] - pt.aws[1])\n\n(pt.gcp <- prop.table(table(gcs.satdata$sat[gcs.satdata$what==\"gcp\"])))\n(pseudo.nps.gcp <- pt.gcp[5] - pt.gcp[3] - pt.gcp[2] - pt.gcp[1])\n\n\n\nlibrary(effects)\nlibrary(lattice)\ntrellis.par.set(list(axis.text = list(cex = 1.2)))  # reset cex\n\nylimits <- c(3.4, 4.6)\nplot(effect(term=c(\"what\"), mod=sat.lm), main=\"Satisfaction for AWS & GCP (N=***)\",\n     xlab=\"Platform rated\", ylab=\"Sat score (1-5)\", ylim=ylimits, alternating = FALSE)\nplot(effect(term=c(\"what\", \"use.azure\"), mod=sat.lm), \n     main=\"SAT with AWS/GCP according to Azure status\",\n     xlab=\"Platform rated\", ylab=\"Sat score (1-5)\", ylim=ylimits, alternating = FALSE)\n\nplot(effect(term=c(\"role\"), mod=sat.lm), \n     main=\"Satisfaction with AWS & GCP, all data by IT Role\",\n     xlab=\"IT Role\", ylab=\"Sat score (1-5)\", ylim=ylimits, alternating = FALSE)\nplot(effect(term=c(\"what\", \"role\"), mod=sat.lm), main=\"SAT with AWS/GCP by IT role\",\n     xlab=\"IT Role\", ylab=\"Sat score (1-5)\", ylim=ylimits, alternating = TRUE)\n\nplot(effect(term=c(\"use.both\"), mod=sat.lm), main=\"Satisfaction for those using (AWS xor GCP) vs. (AWS && GCP)\",\n     xlab=\"Using both AWS && GCP?\",\n     ylab=\"Sat score (1-5)\", ylim=ylimits, alternating = FALSE)\n\nplot(effect(term=c(\"what\", \"use.both\"), mod=sat.lm), main=\"SAT rating for AWS + GCP by whether they use both\",,\n     xlab=\"Platform rated\", \n     ylab=\"Sat score (1-5)\", ylim=ylimits, alternating = FALSE)\n\n\n## inferred income\ntable(gcs.satdata0$Income)\nsum(table(gcs.satdata0$Income)/nrow(gcs.satdata0) * c(10000, 110000, 175000, 30000, \n                                                      30000, 55000, 80000, 55000, \n                                                      55000, 55000))\n\n\n\n## breakouts by platform\n\ntab.aws <- prop.table(table(gcs.satdata0$it.role, gcs.satdata0$use.aws), 2)[,2]\ntab.gcp <- prop.table(table(gcs.satdata0$it.role, gcs.satdata0$use.gcp), 2)[,2]\ncbind(tab.aws, tab.gcp)\n\ntab.aws <- prop.table(table(gcs.satdata0$it.hours, gcs.satdata0$use.aws), 2)[,2]\ntab.gcp <- prop.table(table(gcs.satdata0$it.hours, gcs.satdata0$use.gcp), 2)[,2]\nprint(cbind(tab.aws, tab.gcp) * 100, digits=2)\n\n\n\n\n\n\n\n\n\n###### chart by time\n\n# use data from three.lines above !\n#\nsat.time.mat <- matrix( c(\n  \"AWS\",   \"2015-Q2\", \"79\", \"81\", \"83\", \n  \"GCP\",   \"2015-Q2\", \"73\", \"76\", \"80\",\n  \"GCP\",   \"2015-Q3\", \"76\", \"80\", \"85\",\n  \"Azure\", \"2015-Q3\", \"68\", \"74\", \"80\",\n  \"AWS\",   \"2015-Q4\", \"79\", \"83\", \"86\", \n  \"GCP\",   \"2015-Q4\", \"67\", \"74\", \"80\"), \n  byrow = TRUE, ncol = 5\n)\n\nsat.time <- data.frame(sat.time.mat)\nnames(sat.time) <- c(\"Platform\", \"Time\", \"ci2.5\", \"ci50.0\", \"ci97.5\")\nsat.time$ci2.5 <- as.numeric(as.character(sat.time$ci2.5))\nsat.time$ci50.0 <- as.numeric(as.character(sat.time$ci50.0))\nsat.time$ci97.5 <- as.numeric(as.character(sat.time$ci97.5))\nstr(sat.time)\n\nlibrary(ggplot2)\ndodge <- position_dodge(width=0.1)\np <- ggplot(data=sat.time, \n            aes(x=Time, y=ci50.0, ymax=ci97.5, ymin=ci2.5,\n                colour=Platform, group=Platform)) +\n  geom_point(size=5, position=dodge) + \n  geom_errorbar(width=0.0, size=1.0, position=dodge) +\n  geom_ribbon(aes(fill=Platform), alpha=0.3, position=dodge, linetype=3, colour=\"gray\") +   # aes(ymin=menlelb, ymax=menleub)\n  geom_line(size=1.5, position=dodge) +\n  coord_cartesian(ylim=c(60, 90)) +\n  ylab(\"Percentage satisfied (top 2 box) with 95% CI\") +\n  ggtitle(paste0(\"Overall CSat by time (GCP Q4 N=\", sum(counts.gcp), \n                 \", AWS Q4 N=\", sum(counts.aws),\n                 \") \")) +\n  scale_y_continuous(minor_breaks = seq(62, 88, 2)) +\n  theme(axis.text.x=element_text(size=12, face=\"bold\"),\n        axis.text.y=element_text(size=14),\n        axis.title.x=element_text(size=14),\n        axis.title.y=element_text(size=14),\n        legend.text=element_text(size=14),\n        legend.title=element_text(size=14),\n        plot.title=element_text(size=18, face=\"bold\"))\n\n\np\n\n\n\n\n### SCRATCH\n\n\n\n\nrm(gcs.raw3)\nnames(gcs.clean3)[13:14] <- c(\"profession\", \"cloud.leader\")\n# relabel profession factor\ngcs.clean3$profession <- factor(gcs.clean3$profession, \n                                labels=c(\"Education\", \"Finance\", \"IT\", \"Healthcare\", \"Other\", \"Science\"))\n\nsummary(gcs.clean3[ , 13:14])\nprop.table(table(gcs.clean3[ , 13]))\nprop.table(table(gcs.clean3[ , 14]))\n\n# within profession ratings of leader\nprint(with(gcs.clean3, prop.table(table(cloud.leader, profession), margin=2)), digits=2)\n\n# cross-tab proportions, full sample, profession * leader\nprint(with(gcs.clean3, prop.table(table(cloud.leader, profession))), digits=2)\n\n\n\n\n\n#### RMS workspace ...\n\nlibrary(rms)\n\ndd <- datadist(gcs.satdata)\noptions(datadist=\"dd\")\nsat.rms <- lrm(sat ~ what + use.both + use.both:what + use.azure + use.azure:what +\n                 role + age + urban + it.hours, data=gcs.satdata,\n               x=TRUE, y=TRUE)\nsat.rms\nsummary(sat.rms)\nconfint(sat.rms)\n\nsat.rms.boot <- bootcov(sat.rms, B=1000, maxit=100, coef.reps=TRUE)\nsat.rms.boot\n\nconfplot(sat.rms.boot, X=model.matrix(sat.rms))\n\nmodel.matrix(sat.rms)\n\nPredict(sat.rms.boot)\n\n##### START -- rms HELP\n\nn <- 1000    # define sample size\nset.seed(17) # so can reproduce the results\nage            <- rnorm(n, 50, 10)\nblood.pressure <- rnorm(n, 120, 15)\ncholesterol    <- rnorm(n, 200, 25)\nsex            <- factor(sample(c('female','male'), n,TRUE))\nlabel(age)            <- 'Age'      # label is in Hmisc\nlabel(cholesterol)    <- 'Total Cholesterol'\nlabel(blood.pressure) <- 'Systolic Blood Pressure'\nlabel(sex)            <- 'Sex'\nunits(cholesterol)    <- 'mg/dl'   # uses units.default in Hmisc\nunits(blood.pressure) <- 'mmHg'\n\n# Specify population model for log odds that Y=1\nL <- .4*(sex=='male') + .045*(age-50) +\n  (log(cholesterol - 10)-5.2)*(-2*(sex=='female') + 2*(sex=='male'))\n# Simulate binary y to have Prob(y=1) = 1/[1+exp(-L)]\ny <- ifelse(runif(n) < plogis(L), 1, 0)\n\nddist <- datadist(age, blood.pressure, cholesterol, sex)\noptions(datadist='ddist')\n\nfit <- lrm(y ~ blood.pressure + sex * (age + rcs(cholesterol,4)),\n           x=TRUE, y=TRUE)\nan <- anova(fit)\n# Plot effects of all 4 predictors with test statistics from anova, and P\nplot(Predict(fit), anova=an, pval=TRUE)\nplot(Predict(fit), data=llist(blood.pressure,age))\n# rug plot for two of the predictors\n\n\n##### END HELP\n",
    "created" : 1449521207858.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2411940645",
    "id" : "67F2E326",
    "lastKnownWriteTime" : 1446593003,
    "path" : "~/Documents/Chris Documents/Work/Cloud/gcs-surveys/sat/gcp-gcsSat-2015-1019.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}