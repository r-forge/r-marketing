{
    "contents" : "# gcp-gcsTools-v120150723.R == analysis of GCS tools sat survey\n#\n# author : cchapman\n\n### read data\n# library(gdata)\n# gcs.satT.raw <- read.xls(paste0(\"~/Documents/Chris Documents/Work/Cloud\",\n#                                 \"/gcs-surveys/tools/jan2016\",\n#                                 \"Cloud-Lang1-Mobile-Screen1-20150810.xls\"), \n#                          sheet=3, stringsAsFactors=TRUE)\n\nlibrary(gdata)\ngcs.satT2.raw <- read.xls(paste0(\"~/Documents/Chris Documents/Work/Cloud\",\n                                \"/gcs-surveys/tools/jan2016/\",\n                                \"Cloud-Lang2-Mobile-Screen1 Jan 2016.xls\"))\n\nstr(gcs.satT2.raw)\n\nnames(gcs.satT2.raw)\n\n### make initial clean set\ngcs.satT <- gcs.satT.raw[ , c(4, 5, 6, 7, 8, 13:48)]\nnames(gcs.satT)\nstr(gcs.satT)\n\ntmp.names <- names(gcs.satT)\ntmp.names[6] <- \"it.role\"\ntmp.names[7] <- \"cloud.leader\"\ntmp.names[13] <- \"cloudis.os.none\"\n\ntmp.names[19] <- \"cloudis.goog.none\"\ntmp.names[25] <- \"cloudis.msft.none\"\ntmp.names[26] <- \"using.AWS\"\ntmp.names[27] <- \"using.GCP\"\ntmp.names[31] <- \"using.Azure\"\ntmp.names[32] <- \"using.none\"\n\ntmp.names[33] <- \"code.java\"\ntmp.names[34] <- \"code.c\"\ntmp.names[35] <- \"code..net\"\ntmp.names[36] <- \"code.python\"\ntmp.names[37] <- \"code.ruby\"\ntmp.names[38] <- \"code.php\"\ntmp.names[39] <- \"code.none\"\n\ntmp.names[40] <- \"tool.best\"\ntmp.names[41] <- \"tool.why\"\n\ntmp.names <- gsub(\"Question\\\\.\\\\.7\\\\.Answer\\\\.[[:digit:]]\\\\.\", \"using\", tmp.names)  # replace Q7 items with \"using ...\"\ntmp.names <- gsub(\"Question\\\\.\\\\.[[:digit:]]\\\\.Answer\\\\.[[:digit:]]\\\\.\", \"cloudis\", tmp.names)  # replace all other \"Questions\" with \"cloudis\"\n\ncbind(tmp.names, names(gcs.satT))\nnames(gcs.satT) <- tmp.names\n\nsummary(gcs.satT)\n\n\n# ***\n\n### Quick take on tool pref, GCP vs. AWS\ntmp.use <- ifelse((as.character(gcs.satT$using.AWS) > \" \") & (as.character(gcs.satT$using.GCP) < \"a\"), \"aws\",\n                  ifelse((as.character(gcs.satT$using.AWS) < \"a\") & (as.character(gcs.satT$using.GCP) > \" \"), \"gcp\",\n                         ifelse((as.character(gcs.satT$using.AWS) > \" \") & (as.character(gcs.satT$using.GCP) > \" \"), \"both\", \"none\")))\n\n\ntable(tmp.use, gcs.satT$tool.best)\n\n### Quick take on tool pref, GCP vs. Azure\ntmp.use <- ifelse((as.character(gcs.satT$using.Azure) > \" \") & (as.character(gcs.satT$using.GCP) < \"a\"), \"azure\",\n                  ifelse((as.character(gcs.satT$using.Azure) < \"a\") & (as.character(gcs.satT$using.GCP) > \" \"), \"gcp\",\n                         ifelse((as.character(gcs.satT$using.Azure) > \" \") & (as.character(gcs.satT$using.GCP) > \" \"), \"both\", \"none\")))\n\n\ntable(tmp.use, gcs.satT$tool.best)\n\n# ***\n\n\n##########################################\n### determine \"good\" respondents\n\ngcsT.good <- rep(TRUE, nrow(gcs.satT))   # all good by default\n\n### good step 1 ==> claim cloud\ngcsT.claim.cloud <- apply(gcs.satT[ , 26:31], 1, function(x) sum(as.character(x)>\" \")) > 0\ntable(gcsT.claim.cloud)\n\n\n###\n### good step 2 ==> pass knowledge screener with 11/18 or better\n\ngcs.answer.key <- c(0, 1, 0, 1, 1, 0,   # OS\n                    0, 1, 1, 1, 0, 0,   # Google\n                    0, 1, 0, 1, 1, 0 )  # MSFT\n\ngcsT.score <- rep(NA, nrow(gcs.satT))\nfor (i in seq_along(gcs.satT[, 1])) { gcsT.score[i] <- sum(as.numeric(gcs.satT[i, c(8:13, 14:25)])-1 == gcs.answer.key) }\n\ntable(gcsT.claim.cloud, gcsT.score >= 12)\ntable(gcsT.claim.cloud, gcsT.score >= 11)\ntable(gcsT.score)\n\n###\n### good step 3 ==> get 3/5 correct for the service they use\n\nscore.items <- function(data, pos, neg) {\n  tmp.score <- rep(0, nrow(data))\n  for (i in pos) {\n    tmp.score <- tmp.score + ifelse(as.character(data[ , i]) > \" \", 1, 0)\n  }\n  for (i in neg) {\n    tmp.score <- tmp.score - ifelse(as.character(data[ , i]) > \" \", 1, 0)\n  }\n  return(tmp.score)\n}\n\nuseT.azure <- as.character(gcs.satT$using.Azure) > \" \"\nazT.score <- score.items(gcs.satT, pos=c(21, 23, 24), neg=c(20, 22, 25))\ntable(azT.score)\ngcsT.az.good <- ifelse(useT.azure, azT.score >=2, TRUE)\ntable(gcsT.az.good)\n\nuseT.gcp <- as.character(gcs.satT$using.GCP) > \" \"\ngcpT.score <- score.items(gcs.satT, pos=c(15, 16, 17), neg=c(14, 18, 19))\ntable(gcpT.score)\ngcsT.gcp.good <- ifelse(useT.gcp, gcpT.score >=2, TRUE)\ntable(gcsT.gcp.good)\n\n# for AWS, must get 3/5 on either Azure or GCP\nuseT.aws <- as.character(gcs.satT$using.AWS) > \" \"\ngcsT.aws.good <- ifelse(useT.aws, (azT.score >=2) | (gcpT.score >= 2), TRUE)\ntable(gcsT.aws.good)\n\n\n### FINAL combination of criteria\ngcs.satT.good <- gcsT.claim.cloud &                             # cloud user\n                 as.character(gcs.satT$using.GCP) > \" \" &       # GCP user\n                 (as.character(gcs.satT$using.AWS) > \" \" | \n                    as.character(gcs.satT$using.Azure) > \" \") & # AWS|Azure user\n                 gcsT.az.good & gcsT.gcp.good & gcsT.aws.good & # platform score\n                 gcsT.score >= 12                               # all-up score\n\n\n# &\n#                  ((as.character(gcs.satT$using.AWS) > \" \") |\n#                   (as.character(gcs.satT$using.Azure) > \" \") |\n#                   (as.character(gcs.satT$using.GCP) > \" \"))\n\ntable(gcs.satT.good)\n\n\n# DEMOGRAPHICS\n\n# overall qualify\ntable(gcs.satT.good & (as.character(gcs.satT$using.GCP) > \" \" | \n                       as.character(gcs.satT$using.Azure) > \" \" | \n                       as.character(gcs.satT$using.AWS) > \" \"))\n# GCP users\nprop.table(table(gcs.satT.good, as.character(gcs.satT$using.GCP) > \"\"), margin=1)\n# Azure\nprop.table(table(gcs.satT.good, as.character(gcs.satT$using.Azure) > \"\"), margin=1)\n# AWS\nprop.table(table(gcs.satT.good, as.character(gcs.satT$using.AWS) > \"\"), margin=1)\n\n# GCP and AWS\nwith(gcs.satT[gcs.satT.good, ], prop.table(table(using.GCP, using.AWS), margin=1))\n\n# IT role\nwith(gcs.satT[gcs.satT.good,], prop.table(table(using.GCP, it.role), margin=1))\nwith(gcs.satT[gcs.satT.good,], prop.table(table(using.Azure, it.role), margin=1))\nwith(gcs.satT[gcs.satT.good,], prop.table(table(using.AWS, it.role), margin=1))\n\n# other demographics\n\nwith(gcs.satT[gcs.satT.good,], prop.table(table(Gender)))\nwith(gcs.satT[gcs.satT.good,], prop.table(table(Age)))\nwith(gcs.satT[gcs.satT.good,], prop.table(table(Income)))\n\nwith(gcs.satT[gcs.satT.good,], prop.table(table(using.AWS)))\nwith(gcs.satT[gcs.satT.good,], prop.table(table(using.Azure)))\nwith(gcs.satT[gcs.satT.good,], prop.table(table(using.GCP)))\n\n\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" ,], prop.table(table(code.java)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" ,], prop.table(table(code.c)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" ,], prop.table(table(code..net)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" ,], prop.table(table(code.python)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" ,], prop.table(table(code.ruby)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" ,], prop.table(table(code.php)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" ,], prop.table(table(code.none)))\n\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.GCP) > \"\" ,], prop.table(table(code.java)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.GCP) > \"\" ,], prop.table(table(code.c)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.GCP) > \"\" ,], prop.table(table(code..net)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.GCP) > \"\" ,], prop.table(table(code.python)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.GCP) > \"\" ,], prop.table(table(code.ruby)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.GCP) > \"\" ,], prop.table(table(code.php)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.GCP) > \"\" ,], prop.table(table(code.none)))\n\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" ,], prop.table(table(code.java)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" ,], prop.table(table(code.c)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" ,], prop.table(table(code..net)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" ,], prop.table(table(code.python)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" ,], prop.table(table(code.ruby)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" ,], prop.table(table(code.php)))\nwith(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" ,], prop.table(table(code.none)))\n\n\nget.prefmat <- function(data) {\n  pref.bylang <- data.frame(matrix(nrow=7, ncol=0))\n  \n  pref.bylang$Java <- \n    with(data, \n         prop.table(table(tool.best, code.java), margin=2)[ , 2])\n  pref.bylang$C.CPP <- \n    with(data, \n         prop.table(table(tool.best, code.c), margin=2)[ , 2])\n  pref.bylang$.Net <- \n    with(data, \n         prop.table(table(tool.best, code..net), margin=2)[ , 2])\n  pref.bylang$Python <- \n    with(data, \n         prop.table(table(tool.best, code.python), margin=2)[ , 2])\n  pref.bylang$Ruby <- \n    with(data, \n         prop.table(table(tool.best, code.ruby), margin=2)[ , 2])\n  pref.bylang$PHP <- \n    with(data, \n         prop.table(table(tool.best, code.php), margin=2)[ , 2])\n  pref.bylang$None <- \n    with(data, \n         prop.table(table(tool.best, code.none), margin=2)[ , 2])\n  \n  rownames(pref.bylang) <- levels(data$tool.best)\n  pref.bylang\n  \n}\n\npref.azure <- get.prefmat(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\" , ])\npref.aws <- get.prefmat(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\" , ])\n\n\n#### heat map\n\npref.heat <- function(pref.mat) {\n  library(gplots)\n  library(RColorBrewer)\n  col.pal <- brewer.pal(9, \"RdYlGn\")\n  heatmap.2(as.matrix(pref.mat),\n            Rowv = FALSE, Colv = FALSE, dend = 'none', \n            margins = c(8,16),\n            breaks = c(0, 0.01, 0.05, 0.10, 0.30, 0.4, 0.42, 0.45, 0.47, 0.5),\n            col = col.pal,\n            trace = \"none\",\n            cellnote = round(as.matrix(pref.mat), 2),\n            notecol = \"grey40\", key = FALSE\n            )\n}\n\npref.heat(pref.azure[-3, ])\npref.heat(pref.aws[-3, ])\n\n########### \n\n# for tool preference, replace \"don't know\" with NA\ngcs.satT$tool.best[gcs.satT$tool.best == \"I don't know or am not sure\"] <- NA\n\n# head-to-head vs. others\nwith(gcs.satT[gcs.satT.good,], prop.table(table(tool.best)))\n\n# CIs\nlibrary(MultinomialCI)\n\ngcs.satT.ci <- with(gcs.satT[gcs.satT.good,], cbind(prop.table(table(tool.best)), multinomialCI(table(tool.best), alpha=0.05)))\ngcs.satT.ci <- data.frame(gcs.satT.ci)\nnames(gcs.satT.ci) <- c(\"x50\", \"x2.5\", \"x97.5\")\ngcs.satT.ci$Platform <- rownames(gcs.satT.ci)\n(gcs.satT.ci <- gcs.satT.ci[-3, ])   # remove IDK\n\n## plot CIs\n\ntool.plotci <- function(ci.data, \n                        mlabel=paste0(\"Rated as Best for Dev Tools, N=\", sum(with(gcs.satT[gcs.satT.good,], table(tool.best)))),\n                        ylabel=\"Proportion preferring (with 95% CI)\") {\n  dt <- data.frame(ci.data)\n  names(dt) <- c(\"x50\", \"x2.5\", \"x97.5\")\n  dt$Platform <- rownames(dt) # to get the X var categories\n  dt <- dt[-3, ]   # remove IDK\n  \n  library(ggplot2)\n  library(scales)\n  p <- ggplot(dt, aes(x=Platform, y=x50, ymax=x2.5, ymin=x97.5))\n  p <- p + geom_bar(fill = \"grey50\", stat = \"identity\") \n  p <- p + geom_errorbar(aes(fill=Platform), col=\"red\", width=0.2)\n  p <- p + scale_y_continuous(limits=c(0.0, 0.7),oob = rescale_none) +\n       coord_flip()\n  p <- p + ggtitle(mlabel) + theme(plot.title = element_text(lineheight=1.0, face=\"bold\"))\n  p <- p + labs(x=\"Platform\", y=ylabel) +\n    theme(text = element_text(size=18),\n          axis.text.x = element_text(angle=0, vjust=0.0))\n  p\n}\n\ntool.plotci(gcs.satT.ci)\n\n\n#######\n\n# ** GCP vs. AWS | Azure, only when using both\n(pref.vs.aws.tab <- with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\", ], \n                                   table(tool.best)))\n\n(pref.vs.aws.ci  <- with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\", ], \n                                   cbind(prop.table(table(tool.best)), \n                                          multinomialCI(table(tool.best), alpha=0.05))))\n\ntool.plotci(pref.vs.aws.ci,\n            mlabel=paste0(\"Rated Best Tools by AWS & GCP users, N=\", \n                          sum(with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\",], table(tool.best)))))\n\n(pref.vs.az.tab <- with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\", ], \n                         table(tool.best)))\n\n(pref.vs.az.ci  <- with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\", ], \n                        cbind(prop.table(table(tool.best)), \n                              multinomialCI(table(tool.best), alpha=0.20))))\n\ntool.plotci(pref.vs.az.ci,\n            mlabel=paste0(\"Rated Best Tools by Azure & GCP users, N=\", \n                          sum(with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\",], table(tool.best)))))\n            \n\n# open end explanations\n\n# Pref for AWS vs. GCP\nas.character(na.omit(with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\",], \n             as.character(tool.why[tool.best == \"Amazon Web Services\"]))))\n# Pref for GCP vs. AWS\nas.character(na.omit(with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.AWS) > \"\",], \n             as.character(tool.why[tool.best == \"Google Cloud Platform\"]))))\n\n# Pref for Azure vs. GCP\nas.character(na.omit(with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\",], \n             as.character(tool.why[tool.best == \"Microsoft Azure\"]))))\n# Pref for GCP vs. Azure\nas.character(na.omit(with(gcs.satT[gcs.satT.good & as.character(gcs.satT$using.Azure) > \"\",], \n                          as.character(tool.why[tool.best == \"Google Cloud Platform\"]))))\n\n\n\n# **\n\n\n\n\n\n\n############## CORE SAT :: COUNTS\n\n### Azure sat\nprop.table(table(gcs.sat1z$sat.azure[gcs.sat1z.good & use.azure]))\n\n### GCP sat\nprop.table(table(gcs.sat1z$sat.gcp[gcs.sat1z.good & use.gcp]))\n\n\n### Azure & GCP for users of both\nprop.table(table(gcs.sat1z$sat.azure[gcs.sat1z.good & use.azure & use.gcp]))\nprop.table(table(gcs.sat1z$sat.gcp[gcs.sat1z.good & use.azure & use.gcp]))\n\n\n############## CORE SAT :: Confidence Intervals\n\nlibrary(MultinomialCI)\nalpha <- 0.05\ncount.azure <- as.numeric(table(gcs.sat1z$sat.azure[gcs.sat1z.good & use.azure]))\n(ci.azure    <- multinomialCI(count.azure, alpha))\ncount.gcp   <- as.numeric(table(gcs.sat1z$sat.gcp[gcs.sat1z.good & use.azure]))\n(ci.gcp      <- multinomialCI(count.gcp, alpha))\n\n\n# ** To do: CI plots\n\n\n####### MODELING\n\n### get subset of just good respondents' sat data\ngcs.satdata0 <- cbind(gcs.sat1z[ , c(1,2,4,5,6,27,32,34:36)], good=gcs.sat1z.good, use.azure, use.gcp)\ngcs.satdata0 <- subset(gcs.satdata0, good)\ngcs.satdata0$id <- 1:nrow(gcs.satdata0)\nstr(gcs.satdata0)\n\n\n\n### convert to long format\ngcs.satdata1 <- data.frame(sat=gcs.satdata0[gcs.satdata0$use.azure, \"sat.azure\"], what=\"azure\", \n                           use.both=factor(gcs.satdata0[gcs.satdata0$use.azure, \"use.gcp\"]), \n                           id=gcs.satdata0[gcs.satdata0$use.azure, \"id\"],\n                           use.aws=factor(gcs.satdata0[gcs.satdata0$use.azure, \"using.AWS\"] != \"\"),\n                           role=gcs.satdata0[gcs.satdata0$use.azure, \"it.role\"],\n                           gender=gcs.satdata0[gcs.satdata0$use.azure, \"Gender\"],\n                           age=gcs.satdata0[gcs.satdata0$use.azure, \"Age\"],\n                           urban=gcs.satdata0[gcs.satdata0$use.azure, \"Urban.Density\"],\n                           it.hours=gcs.satdata0[gcs.satdata0$use.azure, \"it.hours\"])\n\ngcs.satdata2 <- data.frame(sat=gcs.satdata0[gcs.satdata0$use.gcp, \"sat.gcp\"], what=\"gcp\", \n                           use.both=factor(gcs.satdata0[gcs.satdata0$use.gcp, \"use.azure\"]), \n                           id=gcs.satdata0[gcs.satdata0$use.gcp, \"id\"],\n                           use.aws=factor(gcs.satdata0[gcs.satdata0$use.gcp, \"using.AWS\"] != \"\"),\n                           role=gcs.satdata0[gcs.satdata0$use.gcp, \"it.role\"],\n                           gender=gcs.satdata0[gcs.satdata0$use.gcp, \"Gender\"],\n                           age=gcs.satdata0[gcs.satdata0$use.gcp, \"Age\"],\n                           urban=gcs.satdata0[gcs.satdata0$use.gcp, \"Urban.Density\"],\n                           it.hours=gcs.satdata0[gcs.satdata0$use.gcp, \"it.hours\"])\n\n\ngcs.satdataz <- rbind(gcs.satdata1, gcs.satdata2)\nstr(gcs.satdataz)\n\ntable(gcs.satdataz$what)\nlevels(gcs.satdataz$role) <- c(\"Management\",\"IT ops\", \"SW Dev\", \"SW Test\")\n\nlibrary(ggplot2)\nlibrary(scales)\n\n# chi-square tests association but treats SAT as nominal, not as ordered\ntable(gcs.satdataz$sat, gcs.satdataz$what)\nchisq.test(table(gcs.satdataz$sat, gcs.satdataz$what))\nprint(prop.table(table(gcs.satdataz$sat, gcs.satdataz$what), margin=2), digits=2)\n\n# CMHtest takes ordinal nature of SAT into account\nlibrary(vcdExtra)\nCMHtest(what ~ sat, data=gcs.satdataz)\n\n# CMH test essentially identical to ANOVA, coding ordinal as 1:K ...\nsummary(aov(as.numeric(sat) ~ what, data=gcs.satdataz))\n\n\n####### PLOTS\n\n# plot them\npar(mfrow=c(1, 1), mar=c(4, 4, 5, 15))\nbarplot(prop.table(table(gcs.satdataz$sat, gcs.satdataz$what), margin=2), \n        beside=TRUE, ylab=\"Proportion of respondents by platform\")\n\npar(xpd=TRUE)\nlegend(\"bottomright\", fill = gray(2:6/7), inset=c(-0.65, 0.01),\n       legend = levels(unique(gcs.satdataz$sat)))\n\n\n# mosaic\nlibrary(vcd)\nmosaicplot(table(gcs.satdataz$what, gcs.satdataz$sat), cex=1, color=T, las=1)  # las sets labels to horizontal (1)\nmosaicplot(table(gcs.satdataz$what, gcs.satdataz$sat), cex=1, color=rev(terrain.colors(5)), las=1)  # las sets labels to horizontal (1)\n\n\n###################\n##\n## ggplot versions with CIs\n\n# function to resample and estimate CIs for raw counts\n#\ncount.boot <- function(count.data, count.levels=NA,\n                       boot.k=1000, big.mult=10000000/sum(count.data), \n                       alpha=0.05, silent=FALSE) {\n  if (length(count.levels) == 1 && is.na(count.levels)) {\n    count.levels <- 1:length(count.data)\n  }\n  extData <- rep(count.levels, times=count.data)\n  \n  boot.k <- 1000\n  boot.out <- matrix(NA, nrow=boot.k, ncol=length(count.data))\n  \n  samp.k <- sum(count.data)\n  \n  if (boot.k > 100 && !silent) {\n    cat(\"Bootstrapping \")\n  }\n  \n  for (i in 1:boot.k) {\n    if (!silent && i %% 100 == 0) {\n      cat(\".\")\n    }\n    boot.samp <- sample(extData, samp.k, replace=TRUE)\n    boot.p <- prop.table(table(factor(boot.samp, levels=count.levels)))\n    boot.out[i, ] <- as.numeric(boot.p)\n  }\n  \n  if (boot.k > 100 && !silent) {\n    cat(\" done.\\n\\n\")\n  }\n  \n  return(t(apply(boot.out, 2, \n                 function(x) quantile(x, probs=c(alpha/2, 0.5, 1-alpha/2)))))\n}\n\n\ncount.plotci <- function(dt, mlabel=\"Ratings\", ylabel=\"Proportion (with 95% CI)\") {\n  library(ggplot2)\n  p <- ggplot(dt, aes(x=Sat, y=X50., ymax=X2.5., ymin=X97.5.))\n  p <- p + geom_bar(fill = \"grey50\", stat = \"identity\") \n  p <- p + geom_errorbar(aes(fill=Sat), col=\"red\", width=0.2)\n  p <- p + scale_y_continuous(limits=c(0.0, 0.6),oob = rescale_none)\n  p <- p + ggtitle(mlabel) + theme(plot.title = element_text(lineheight=1.0, face=\"bold\"))\n  p <- p + labs(x=\"Satisfaction rating\", y=ylabel) +\n           theme(text = element_text(size=14),\n           axis.text.x = element_text(angle=-10, vjust=0.6))\n  p\n}\n\n# plot Sat for GCP\ncounts.gcp <- table(gcs.satdataz$sat[gcs.satdataz$what==\"gcp\"])\ncount.gcp.ci <- count.boot(counts.gcp)\ncount.ci.df <- data.frame(count.gcp.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat1z$sat.gcp))\ncount.plotci(count.ci.df, mlabel=\"GCP Satisfaction Ratings (N=284)\")\n\n# plot Sat for Azure\n(counts.az <- table(gcs.satdataz$sat[gcs.satdataz$what==\"azure\"]))\ncount.az.ci <- count.boot(counts.az)\ncount.ci.df <- data.frame(count.az.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat1z$sat.azure))\ncount.plotci(count.ci.df, mlabel=\"Azure Satisfaction Ratings (N=211)\")\n\n\n# GCP, FT dev only\n(counts.gcp <- table(gcs.satdataz$sat[gcs.satdataz$what==\"gcp\" &\n                                       gcs.satdataz$role==\"SW Dev\" &\n                                       gcs.satdataz$it.hours==\"Work full time in IT\"]))\n\ncount.gcp.ci <- count.boot(counts.gcp)\ncount.ci.df <- data.frame(count.gcp.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat1z$sat.gcp))\ncount.plotci(count.ci.df, mlabel=paste0(\"FT Developer GCP Sat (N=\", sum(counts.gcp), \")\"))\n\n# Azure, FT dev only\n(counts.gcp <- table(gcs.satdataz$sat[gcs.satdataz$what==\"azure\" &\n                                        gcs.satdataz$role==\"SW Dev\" &\n                                        gcs.satdataz$it.hours==\"Work full time in IT\"]))\n\ncount.gcp.ci <- count.boot(counts.gcp)\ncount.ci.df <- data.frame(count.gcp.ci)\ncount.ci.df$Sat <- paste(1:5, levels(gcs.sat1z$sat.gcp))\ncount.plotci(count.ci.df, mlabel=paste0(\"FT Developer Azure Sat (N=\", sum(counts.gcp), \")\"))\n\n\n###### three number bootstrap for high-level bucket CIs\n\nthree.boot <- function(count.data, count.levels=NA,\n                       boot.k=1000, alpha=0.05, \n                       silent=FALSE, samp.k=sum(count.data)) {\n  if (length(count.levels) == 1 && is.na(count.levels)) {\n    count.levels <- 1:length(count.data)\n  }\n  extData <- rep(count.levels, times=count.data)\n\n  boot.out <- matrix(NA, nrow=boot.k, ncol=3)\n  \n  if (boot.k > 100 && !silent) {\n    cat(\"Bootstrapping \")\n  }\n  \n  for (i in 1:boot.k) {\n    if (!silent && i %% 100 == 0) {\n      cat(\".\")\n    }\n    boot.samp <- sample(extData, samp.k, replace=TRUE)\n    boot.p <- prop.table(table(factor(boot.samp, levels=count.levels)))\n    # top 2 box\n    boot.out[i, 1] <- as.numeric(boot.p[5]) + as.numeric(boot.p[4])\n    # top 2 box\n    boot.out[i, 2] <- as.numeric(boot.p[5])\n    # pseudo NPS\n    boot.out[i, 3] <- as.numeric(boot.p[5]) - as.numeric(boot.p[3]) - as.numeric(boot.p[2]) - as.numeric(boot.p[1])\n  }\n  \n  if (boot.k > 100 && !silent) {\n    cat(\" done.\\n\\n\")\n  }\n  \n  return(t(apply(boot.out, 2, \n                 function(x) quantile(x, probs=c(alpha/2, 0.5, 1-alpha/2)))))\n}\n\n## GCP\n(counts.gcp <- table(gcs.satdataz$sat[gcs.satdataz$what==\"gcp\"]))\nset.seed(98103)\nthree.lines <- \"\"\n\nfor (n.samp in sum(counts.gcp)) {\n  \n  cat(\"Sample size = \", n.samp, \"\\n\")\n  three.res <- three.boot(counts.gcp, samp.k=n.samp, boot.k=1000)\n  three.txt <- paste0(\", N = \", n.samp, \",\",\n                      round(three.res[1,1],2), \"-\", round(three.res[1,3],2), \",\",\n                      round(three.res[2,1],2), \"-\", round(three.res[2,3],2), \",\",\n                      round(three.res[3,1],2), \"-\", round(three.res[3,3],2))\n  \n  three.lines <- rbind(three.lines, three.txt)\n  \n}\nthree.lines\n\n# Azure\n(counts.az <- table(gcs.satdataz$sat[gcs.satdataz$what==\"azure\"]))\nset.seed(98103)\nthree.lines <- \"\"\n\nfor (n.samp in sum(counts.az)) {\n  \n  cat(\"Sample size = \", n.samp, \"\\n\")\n  three.res <- three.boot(counts.az, samp.k=n.samp, boot.k=1000)\n  three.txt <- paste0(\", N = \", n.samp, \",\",\n                      round(three.res[1,1],2), \"-\", round(three.res[1,3],2), \",\",\n                      round(three.res[2,1],2), \"-\", round(three.res[2,3],2), \",\",\n                      round(three.res[3,1],2), \"-\", round(three.res[3,3],2))\n  \n  three.lines <- rbind(three.lines, three.txt)\n  \n}\nthree.lines\n\n\n######## REGRESSION\n\n\n## test regression from melted data\n\n\n####  ===>    need to update for NON-mixed model\n\n# basic lm model -- using sat as numeric for simplicity -- to test VIF, etc\n# for Azure data, had to cut AWS interactions and mixed model, due to collinearity\n# ====>>  had to drop IT.hours due to insufficient data points // singular matrix\nsat.lm0z <- lm(as.numeric(sat) ~ what + use.both + use.both:what + use.aws + role , \n               data=gcs.satdataz )\n\nsummary(sat.lm0z)\nlibrary(car)\nvif(sat.lm0z)    # looks OK\n\n\n### Ordinal version\nlibrary(ordinal)\nsat.clm.z <- clm(sat ~ what + use.both + use.both:what + use.aws + role, \n                 data=gcs.satdataz )\nsummary(sat.clm.z)\n\nsat.clm.ci0z <- confint(sat.clm.z)\n\nsat.clm.ciz <- cbind(ci2.5=sat.clm.ci0z[1:7,1],  ci97.5=sat.clm.ci0z[1:7,2], \n                     ci50=as.numeric(coef(sat.clm.z)[5:11]))\n\n\n#### **\n\n\n### Figure INFERRED sat from coefficients\n###\n### using CLM \n\n\n### clm.pred() adapted from CLMM vignette, Christensen 2015, p. 7\nclm.pred <- function(eta, theta, cat = 1:(length(theta)+1), inv.link = plogis) {\n  Theta <- c(-1e3, theta, 1e3)\n  sapply(cat, \n         function(j) inv.link(Theta[j+1] - eta) - inv.link(Theta[j] - eta) )\n}\n    \n# clm.pred(qnorm(0.05) * sat.clm.z$stDev, sat.clm.z$Theta)  # stdev only applies for mixed model\n\n\n?clmm2\n\nsat.modeled <- data.frame(azure = c(VerySatisfied=0, SomewhatSatisfied=0, Neither=0, SomewhatDissatisfied=0, VeryDissatisfied=0),\n                          gcp   = c(VerySatisfied=0, SomewhatSatisfied=0, Neither=0, SomewhatDissatisfied=0, VeryDissatisfied=0))\n\n(sat.modeled$azure <- diff(plogis(c(-Inf, sat.clm.z$Theta-sat.clm.z$beta[5], Inf))))  # Azure, Dev\n(sat.modeled$gcp   <- diff(plogis(c(-Inf, sat.clm.z$Theta-sat.clm.z$beta[1]-sat.clm.z$beta[5], Inf))))  # GCP, Dev\n\nsat.mod.tab <- as.table(setNames(sat.modeled$azure, rev(row.names(sat.modeled))))\nsat.mod.tab <- rbind(sat.mod.tab, sat.modeled$gcp)\ndimnames(sat.mod.tab)[[1]] <- c(\"Azure\", \"GCP\")\nsat.mod.tab\n\npar(mfrow=c(1, 1), mar=c(4, 4, 5, 15))\nbarplot(t(sat.mod.tab),\n        beside=TRUE, ylab=\"Proportion of respondents by platform\",\n        main=\"Inferred developer satisfaction from model\")\n\npar(xpd=TRUE)\nlegend(\"bottomright\", fill = gray(2:6/7), inset=c(-0.65, 0.01),\n       legend = levels(gcs.satdata0$sat.gcp))\n\n\n## INFERRED developer pseudo NPS\nsat.mod.tab[,4] + sat.mod.tab[,5]  # top 2 box\nsat.mod.tab[,5] - sat.mod.tab[,1]-sat.mod.tab[,2]-sat.mod.tab[,3]   # Pseudo NPS\n\n\n\n### **\n\n### CI plot for CLM\n\n\nci.plot <- function(cidata, setnames=FALSE, ci.alpha=0.95, xlab=\"\", ci.title=\"% CI for Effect by Factor\") {\n  ci.df <- data.frame(cidata)\n  # set factor manually in order to force the level order to match lm\n  if (setnames) {\n    rownames(ci.df) <- c(\"Using GCP\", \"Using GCP&AWS\", \"Using Azure\", \n                         \"IT Ops\", \"SW Dev\", \"SW Test\", \n                         #                     \"Male\", \"Age35-44\", \"Age45-54\", \"Age55+\", \n                         #                     \"Suburban\", \"Urban\", \n                         \"Not working\", \"IT FTE\", \"Non-IT FTE\", \"FTE +IT PTE\", \"IT PTE\", \"Non-IT PTE\", \n                         \"GCP penalty if +AWS\", \"GCP bump if +Azure\")\n  }\n  ci.df$Factor <- factor(rownames(ci.df), levels=rev(rownames(ci.df)))\n  \n  # basic plot with segment, 50% and 95% limits\n  p <- ggplot(ci.df, aes(x=Factor, y=ci50, ymax=ci2.5, ymin=ci97.5))\n  p <- p + geom_point(size=4) + geom_errorbar(width=0.2) + \n    theme(axis.text.x = element_text(colour=\"grey20\",size=16)) +\n    theme(axis.text.y = element_text(colour=\"grey20\",size=16)) +\n    \n    ylab(xlab) +\n    geom_hline(yintercept=0, linetype=\"dotted\", size=1.5, color=\"red\")\n  p + ggtitle(paste0(ci.alpha*100, ci.title)) + coord_flip()\n  \n}\n\n\nsat.lm.ci <- data.frame(cbind(confint(sat.lm0z), coef(sat.lm0z)))\nsat.lm.ci <- sat.lm.ci[-1, ] # remove intercept\nnames(sat.lm.ci) <- c(\"ci2.5\", \"ci97.5\", \"ci50\")\n\nci.plot(sat.lm.ci, setnames=FALSE, xlab=\"Effect (points of satisfaction)\")\n\nci.plot(2*plogis(sat.clm.ciz)-1, setnames=FALSE, xlab=\"Effect (rescaled logit units)\")\n\n\n### **\n\n\n\n### NPS like scores\n(pt.azure <- prop.table(table(gcs.satdataz$sat[gcs.satdataz$what==\"azure\"])))\n(pseudo.nps.aws <- pt.azure[5] - pt.azure[3] - pt.azure[2] - pt.azure[1])\n\n(pt.gcp <- prop.table(table(gcs.satdataz$sat[gcs.satdataz$what==\"gcp\"])))\n(pseudo.nps.gcp <- pt.gcp[5] - pt.gcp[3] - pt.gcp[2] - pt.gcp[1])\n\n\n\nlibrary(effects)\nlibrary(lattice)\ntrellis.par.set(list(axis.text = list(cex = 1.2)))  # reset cex\n\nplot(effect(term=c(\"what\"), mod=sat.lm0z), main=\"Satisfaction for Azure & GCP (N=495)\",\n     xlab=\"Platform rated\", ylab=\"Sat score (1-5)\", ylim=c(3.3, 4.6), alternating = FALSE)\n\n\nplot(effect(term=c(\"what\", \"role\"), mod=sat.lm0z), main=\"SAT with Azure/GCP by IT role\",\n     xlab=\"IT Role\", ylab=\"Sat score (1-5)\", ylim=c(3.3, 4.6), alternating = TRUE)\n\nplot(effect(term=c(\"what\", \"use.aws\"), mod=sat.lm0z), main=\"SAT with Azure/GCP according to AWS status\",\n     xlab=\"Platform rated\", ylab=\"Sat score (1-5)\", ylim=c(3.3, 4.6), alternating = FALSE)\n\nplot(effect(term=c(\"what\", \"use.both\"), mod=sat.lm0z), main=\"SAT rating for Azure + GCP by whether they use both\",\n     xlab=\"Platform rated\", \n     ylab=\"Sat score (1-5)\", ylim=c(3.3, 4.6), alternating = FALSE)\n\n\n## inferred income\nsum(table(gcs.satT$Income)/nrow(gcs.satT) * c(10000, 110000, 175000, 30000, \n                                              55000, 80000,  55000, 55000, \n                                              55000))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## breakouts by platform\n\ntab.az <- prop.table(table(gcs.satdata0$it.role, gcs.satdata0$use.azure), 2)[,2]\ntab.gcp <- prop.table(table(gcs.satdata0$it.role, gcs.satdata0$use.gcp), 2)[,2]\ncbind(tab.az, tab.gcp)\n\ntab.az <- prop.table(table(gcs.satdata0$it.hours, gcs.satdata0$use.azure), 2)[,2]\ntab.gcp <- prop.table(table(gcs.satdata0$it.hours, gcs.satdata0$use.gcp), 2)[,2]\nprint(cbind(tab.az, tab.gcp) * 100, digits=2)\n\n\n\n\n\n\n\n\n### SCRATCH\n\n\n\n\nrm(gcs.raw3)\nnames(gcs.clean3)[13:14] <- c(\"profession\", \"cloud.leader\")\n# relabel profession factor\ngcs.clean3$profession <- factor(gcs.clean3$profession, \n                                labels=c(\"Education\", \"Finance\", \"IT\", \"Healthcare\", \"Other\", \"Science\"))\n\nsummary(gcs.clean3[ , 13:14])\nprop.table(table(gcs.clean3[ , 13]))\nprop.table(table(gcs.clean3[ , 14]))\n\n# within profession ratings of leader\nprint(with(gcs.clean3, prop.table(table(cloud.leader, profession), margin=2)), digits=2)\n\n# cross-tab proportions, full sample, profession * leader\nprint(with(gcs.clean3, prop.table(table(cloud.leader, profession))), digits=2)\n\n\n\n\n\n\n######### small sample bootstrap for comparison\n\n\n\n\n\n\n#### RMS workspace ...\n\nlibrary(rms)\n\ndd <- datadist(gcs.satdata)\noptions(datadist=\"dd\")\nsat.rms <- lrm(sat ~ what + use.both + use.both:what + use.azure + use.azure:what +\n                 role + age + urban + it.hours, data=gcs.satdata,\n               x=TRUE, y=TRUE)\nsat.rms\nsummary(sat.rms)\nconfint(sat.rms)\n\nsat.rms.boot <- bootcov(sat.rms, B=1000, maxit=100, coef.reps=TRUE)\nsat.rms.boot\n\nconfplot(sat.rms.boot, X=model.matrix(sat.rms))\n\nmodel.matrix(sat.rms)\n\nPredict(sat.rms.boot)\n\n##### START -- rms HELP\n\nn <- 1000    # define sample size\nset.seed(17) # so can reproduce the results\nage            <- rnorm(n, 50, 10)\nblood.pressure <- rnorm(n, 120, 15)\ncholesterol    <- rnorm(n, 200, 25)\nsex            <- factor(sample(c('female','male'), n,TRUE))\nlabel(age)            <- 'Age'      # label is in Hmisc\nlabel(cholesterol)    <- 'Total Cholesterol'\nlabel(blood.pressure) <- 'Systolic Blood Pressure'\nlabel(sex)            <- 'Sex'\nunits(cholesterol)    <- 'mg/dl'   # uses units.default in Hmisc\nunits(blood.pressure) <- 'mmHg'\n\n# Specify population model for log odds that Y=1\nL <- .4*(sex=='male') + .045*(age-50) +\n  (log(cholesterol - 10)-5.2)*(-2*(sex=='female') + 2*(sex=='male'))\n# Simulate binary y to have Prob(y=1) = 1/[1+exp(-L)]\ny <- ifelse(runif(n) < plogis(L), 1, 0)\n\nddist <- datadist(age, blood.pressure, cholesterol, sex)\noptions(datadist='ddist')\n\nfit <- lrm(y ~ blood.pressure + sex * (age + rcs(cholesterol,4)),\n           x=TRUE, y=TRUE)\nan <- anova(fit)\n# Plot effects of all 4 predictors with test statistics from anova, and P\nplot(Predict(fit), anova=an, pval=TRUE)\nplot(Predict(fit), data=llist(blood.pressure,age))\n# rug plot for two of the predictors\n\n\n##### END HELP\n",
    "created" : 1453837415317.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3707527287",
    "id" : "D6B164E",
    "lastKnownWriteTime" : 1453837606,
    "path" : "~/Documents/Chris Documents/Work/Cloud/gcs-surveys/tools/gcp-gcsTools-v2-20160126.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}